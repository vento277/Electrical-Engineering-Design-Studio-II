// -------------------------------------------------------------
// 
// File Name: C:\Users\TEMP\Desktop\fina\hdlcoder_commviterbi\ACSRenorm.v
// Created: 2024-06-14 20:40:48
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: ACSRenorm
// Source Path: hdlcoder_commviterbi/Subsystem/Viterbi Decoder/ACS/ACSRenorm
// Hierarchy Level: 3
// 
// Calculates the minimum state metric value
// Compares the minimum value to the threshold parameter
// If the minimum value is greater than or equal to the threshold value, 
// returns the step parameter; otherwise returns zero
// 
// State Metric Renormalization
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module ACSRenorm
          (clk,
           reset,
           enb,
           stMet_0,
           stMet_1,
           stMet_2,
           stMet_3,
           normval,
           idx);


  input   clk;
  input   reset;
  input   enb;
  input   [3:0] stMet_0;  // ufix4
  input   [3:0] stMet_1;  // ufix4
  input   [3:0] stMet_2;  // ufix4
  input   [3:0] stMet_3;  // ufix4
  output  [3:0] normval;  // ufix4
  output  [1:0] idx;  // ufix2


  wire [3:0] stMet [0:3];  // ufix4 [4]
  reg [3:0] dstMet [0:3];  // ufix4 [4]
  wire [3:0] stMet_reorder [0:3];  // ufix4 [4]
  reg [3:0] dstMet_reorder [0:3];  // ufix4 [4]
  wire [1:0] const_idx [0:3];  // ufix2 [4]
  wire [0:1] MinimumTree_treestage1_isless;  // boolean [2]
  wire [3:0] MinimumTree_stage1_val [0:1];  // ufix4 [2]
  wire [1:0] MinimumTree_stage1_idx [0:1];  // ufix2 [2]
  reg [3:0] MinimumTree_stage1_val_reg [0:1];  // ufix4 [2]
  reg [1:0] MinimumTree_stage1_idx_reg [0:1];  // ufix2 [2]
  wire MinimumTree_treestage2_isless;
  wire [3:0] MinimumTree_stage2_val;  // ufix4
  wire [1:0] MinimumTree_stage2_idx;  // ufix2
  reg [3:0] MinimumTree_stage2_val_reg;  // ufix4
  wire sel;  // ufix1
  wire switch_compare_1;
  wire [3:0] conststep;  // ufix4
  wire [3:0] constzero;  // ufix4
  wire [1:0] idxmax;  // ufix2
  reg [1:0] MinimumTree_stage2_idx_reg;  // ufix2


  assign stMet[0] = stMet_0;
  assign stMet[1] = stMet_1;
  assign stMet[2] = stMet_2;
  assign stMet[3] = stMet_3;

  // Add input register for state metric
  always @(posedge clk or posedge reset)
    begin : stMetRegister_process
      if (reset == 1'b1) begin
        dstMet[0] <= 4'b0111;
        dstMet[1] <= 4'b0111;
        dstMet[2] <= 4'b0111;
        dstMet[3] <= 4'b0000;
      end
      else begin
        if (enb) begin
          dstMet[0] <= stMet[0];
          dstMet[1] <= stMet[1];
          dstMet[2] <= stMet[2];
          dstMet[3] <= stMet[3];
        end
      end
    end



  // Reorder state metric to match the minimum idx search
  assign stMet_reorder[0] = dstMet[3];
  assign stMet_reorder[1] = dstMet[2];
  assign stMet_reorder[2] = dstMet[1];
  assign stMet_reorder[3] = dstMet[0];

  always @(posedge clk or posedge reset)
    begin : MininputRegister_process
      if (reset == 1'b1) begin
        dstMet_reorder[0] <= 4'b0111;
        dstMet_reorder[1] <= 4'b0111;
        dstMet_reorder[2] <= 4'b0111;
        dstMet_reorder[3] <= 4'b0000;
      end
      else begin
        if (enb) begin
          dstMet_reorder[0] <= stMet_reorder[0];
          dstMet_reorder[1] <= stMet_reorder[1];
          dstMet_reorder[2] <= stMet_reorder[2];
          dstMet_reorder[3] <= stMet_reorder[3];
        end
      end
    end



  assign const_idx[0] = 2'b00;
  assign const_idx[1] = 2'b01;
  assign const_idx[2] = 2'b10;
  assign const_idx[3] = 2'b11;



  // ---- Tree min implementation ----
  // ---- Tree min stage 1 ----
  assign MinimumTree_treestage1_isless[0] = (dstMet_reorder[0] <= dstMet_reorder[1] ? 1'b1 :
              1'b0);
  assign MinimumTree_stage1_val[0] = (MinimumTree_treestage1_isless[0] ? dstMet_reorder[0] :
              dstMet_reorder[1]);
  assign MinimumTree_stage1_idx[0] = (MinimumTree_treestage1_isless[0] ? const_idx[0] :
              const_idx[1]);
  assign MinimumTree_treestage1_isless[1] = (dstMet_reorder[2] <= dstMet_reorder[3] ? 1'b1 :
              1'b0);
  assign MinimumTree_stage1_val[1] = (MinimumTree_treestage1_isless[1] ? dstMet_reorder[2] :
              dstMet_reorder[3]);
  assign MinimumTree_stage1_idx[1] = (MinimumTree_treestage1_isless[1] ? const_idx[2] :
              const_idx[3]);



  always @(posedge clk or posedge reset)
    begin : MinimumTree_stage1_val_1_process
      if (reset == 1'b1) begin
        MinimumTree_stage1_val_reg[0] <= 4'b0000;
        MinimumTree_stage1_val_reg[1] <= 4'b0000;
      end
      else begin
        if (enb) begin
          MinimumTree_stage1_val_reg[0] <= MinimumTree_stage1_val[0];
          MinimumTree_stage1_val_reg[1] <= MinimumTree_stage1_val[1];
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : MinimumTree_stage1_idx_1_process
      if (reset == 1'b1) begin
        MinimumTree_stage1_idx_reg[0] <= 2'b00;
        MinimumTree_stage1_idx_reg[1] <= 2'b00;
      end
      else begin
        if (enb) begin
          MinimumTree_stage1_idx_reg[0] <= MinimumTree_stage1_idx[0];
          MinimumTree_stage1_idx_reg[1] <= MinimumTree_stage1_idx[1];
        end
      end
    end



  // ---- Tree min stage 2 ----
  assign MinimumTree_treestage2_isless = MinimumTree_stage1_val_reg[0] <= MinimumTree_stage1_val_reg[1];
  assign MinimumTree_stage2_val = (MinimumTree_treestage2_isless ? MinimumTree_stage1_val_reg[0] :
              MinimumTree_stage1_val_reg[1]);
  assign MinimumTree_stage2_idx = (MinimumTree_treestage2_isless ? MinimumTree_stage1_idx_reg[0] :
              MinimumTree_stage1_idx_reg[1]);



  always @(posedge clk or posedge reset)
    begin : MinimumTree_stage2_val_1_process
      if (reset == 1'b1) begin
        MinimumTree_stage2_val_reg <= 4'b0000;
      end
      else begin
        if (enb) begin
          MinimumTree_stage2_val_reg <= MinimumTree_stage2_val;
        end
      end
    end



  assign sel = MinimumTree_stage2_val_reg < 4'b0101;



  assign switch_compare_1 = sel > 1'b0;



  // Normalization constant adjustment value
  assign conststep = 4'b1111;



  // Normalization constant zero
  assign constzero = 4'b0000;



  assign normval = (switch_compare_1 == 1'b0 ? conststep :
              constzero);



  // Max value of state index
  assign idxmax = 2'b11;



  always @(posedge clk or posedge reset)
    begin : MinimumTree_stage2_idx_1_process
      if (reset == 1'b1) begin
        MinimumTree_stage2_idx_reg <= 2'b00;
      end
      else begin
        if (enb) begin
          MinimumTree_stage2_idx_reg <= MinimumTree_stage2_idx;
        end
      end
    end



  assign idx = idxmax - MinimumTree_stage2_idx_reg;



endmodule  // ACSRenorm

