// -------------------------------------------------------------
// 
// File Name: C:\Users\TEMP\Desktop\fina\hdlcoder_commviterbi\Viterbi_Decoder.v
// Created: 2024-06-14 20:40:48
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Viterbi_Decoder
// Source Path: hdlcoder_commviterbi/Subsystem/Viterbi Decoder
// Hierarchy Level: 1
// 
// Top level of Viterbi Decoder, consists of three basic components: Branch Metric, ACS,and Traceback 
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Viterbi_Decoder
          (clk,
           reset,
           enb,
           Viterbi_Decoder_in_0,
           Viterbi_Decoder_in_1,
           decoded);


  input   clk;
  input   reset;
  input   enb;
  input   Viterbi_Decoder_in_0;  // ufix1
  input   Viterbi_Decoder_in_1;  // ufix1
  output  decoded;


  wire [0:1] Viterbi_Decoder_in;  // ufix1 [2]
  reg  [0:1] InputRegister_reg;  // ufix1 [2]
  wire [0:1] InputRegister_reg_next;  // ufix1 [2]
  wire [0:1] regin;  // ufix1 [2]
  wire [1:0] bMet_0;  // ufix2
  wire [1:0] bMet_1;  // ufix2
  wire [1:0] bMet_2;  // ufix2
  wire [1:0] bMet_3;  // ufix2
  wire [1:0] bMet [0:3];  // ufix2 [4]
  reg [1:0] regBMet [0:3];  // ufix2 [4]
  wire dec_0;  // ufix1
  wire dec_1;  // ufix1
  wire dec_2;  // ufix1
  wire dec_3;  // ufix1
  wire [1:0] idx;  // ufix2
  wire [0:3] dec;  // ufix1 [4]
  reg  [0:3] regdec;  // ufix1 [4]
  reg [1:0] regidx;  // ufix2
  wire decoded_1;  // ufix1
  reg  outreg;  // ufix1


  assign Viterbi_Decoder_in[0] = Viterbi_Decoder_in_0;
  assign Viterbi_Decoder_in[1] = Viterbi_Decoder_in_1;

  // Input Register
  always @(posedge clk or posedge reset)
    begin : InputRegister_process
      if (reset == 1'b1) begin
        InputRegister_reg[0] <= 1'b0;
        InputRegister_reg[1] <= 1'b0;
      end
      else begin
        if (enb) begin
          InputRegister_reg[0] <= InputRegister_reg_next[0];
          InputRegister_reg[1] <= InputRegister_reg_next[1];
        end
      end
    end

  assign regin[0] = InputRegister_reg[0];
  assign regin[1] = InputRegister_reg[1];
  assign InputRegister_reg_next[0] = Viterbi_Decoder_in[0];
  assign InputRegister_reg_next[1] = Viterbi_Decoder_in[1];



  BranchMetric u_BMet_inst (.din_0(regin[0]),  // ufix1
                            .din_1(regin[1]),  // ufix1
                            .bMet_0(bMet_0),  // ufix2
                            .bMet_1(bMet_1),  // ufix2
                            .bMet_2(bMet_2),  // ufix2
                            .bMet_3(bMet_3)  // ufix2
                            );

  assign bMet[0] = bMet_0;
  assign bMet[1] = bMet_1;
  assign bMet[2] = bMet_2;
  assign bMet[3] = bMet_3;

  // Branch Metric output Register
  always @(posedge clk or posedge reset)
    begin : BMetRegister_process
      if (reset == 1'b1) begin
        regBMet[0] <= 2'b00;
        regBMet[1] <= 2'b00;
        regBMet[2] <= 2'b00;
        regBMet[3] <= 2'b00;
      end
      else begin
        if (enb) begin
          regBMet[0] <= bMet[0];
          regBMet[1] <= bMet[1];
          regBMet[2] <= bMet[2];
          regBMet[3] <= bMet[3];
        end
      end
    end



  ACS u_ACS_inst (.clk(clk),
                  .reset(reset),
                  .enb(enb),
                  .acs_in_0(regBMet[0]),  // ufix2
                  .acs_in_1(regBMet[1]),  // ufix2
                  .acs_in_2(regBMet[2]),  // ufix2
                  .acs_in_3(regBMet[3]),  // ufix2
                  .dec_0(dec_0),  // ufix1
                  .dec_1(dec_1),  // ufix1
                  .dec_2(dec_2),  // ufix1
                  .dec_3(dec_3),  // ufix1
                  .idx(idx)  // ufix2
                  );

  assign dec[0] = dec_0;
  assign dec[1] = dec_1;
  assign dec[2] = dec_2;
  assign dec[3] = dec_3;

  // ACS dec output Register
  always @(posedge clk or posedge reset)
    begin : decRegister_process
      if (reset == 1'b1) begin
        regdec[0] <= 1'b0;
        regdec[1] <= 1'b0;
        regdec[2] <= 1'b0;
        regdec[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          regdec[0] <= dec[0];
          regdec[1] <= dec[1];
          regdec[2] <= dec[2];
          regdec[3] <= dec[3];
        end
      end
    end



  // ACS idx output Register
  always @(posedge clk or posedge reset)
    begin : idxRegister_process
      if (reset == 1'b1) begin
        regidx <= 2'b00;
      end
      else begin
        if (enb) begin
          regidx <= idx;
        end
      end
    end



  Traceback u_Traceback_inst (.clk(clk),
                              .reset(reset),
                              .enb(enb),
                              .dec_0(regdec[0]),  // ufix1
                              .dec_1(regdec[1]),  // ufix1
                              .dec_2(regdec[2]),  // ufix1
                              .dec_3(regdec[3]),  // ufix1
                              .idx(regidx),  // ufix2
                              .decoded(decoded_1)  // ufix1
                              );

  // Viterbi Decoder output Register
  always @(posedge clk or posedge reset)
    begin : DecoderoutputRegister_process
      if (reset == 1'b1) begin
        outreg <= 1'b0;
      end
      else begin
        if (enb) begin
          outreg <= decoded_1;
        end
      end
    end



  // Output data type conversion
  assign decoded = (outreg != 1'b0 ? 1'b1 :
              1'b0);



endmodule  // Viterbi_Decoder

